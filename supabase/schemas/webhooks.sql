-- Webhooks System Configuration using PGMQ + PG_NET + PG_CRON

-- 1. Ensure Extensions are enabled
CREATE EXTENSION IF NOT EXISTS pgmq;
CREATE EXTENSION IF NOT EXISTS pg_net;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. Create the Queue 'pomodoro_webhooks'
-- Idempotent creation (PGMQ creates tables if they don't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pgmq.list_queues() WHERE queue_name = 'pomodoro_webhooks') THEN
        PERFORM pgmq.create('pomodoro_webhooks');
    END IF;
END $$;

-- 3. Trace Table (Audit Log)
-- Links PGMQ message with PG_NET request
drop table if exists public.webhook_trace;
CREATE TABLE public.webhook_trace (
    id bigint generated by default as identity primary key,
    pgmq_msg_id bigint,          -- Message ID (in queue or archive)
    net_request_id bigint,       -- Request ID from pg_net
    processed_at timestamp with time zone default now(),
    user_id uuid REFERENCES auth.users(id) -- Track user for RLS
);

CREATE INDEX IF NOT EXISTS idx_webhook_trace_msg_id ON public.webhook_trace(pgmq_msg_id);

-- Enable RLS for traceability
ALTER TABLE public.webhook_trace ENABLE ROW LEVEL SECURITY;

-- Allow users to view only their own logs
DROP POLICY IF EXISTS "Users can view their own webhook traces" ON public.webhook_trace;
CREATE POLICY "Users can view their own webhook traces" 
ON public.webhook_trace 
FOR SELECT 
TO authenticated 
USING (user_id = (select auth.uid()));


-- 4. CLEANUP OLD LOGIC (Important to avoid double sending)
DROP TRIGGER IF EXISTS trigger_pomodoro_finished_webhook ON public.pomodoros;
DROP FUNCTION IF EXISTS public.handle_pomodoro_finished_webhook();

DROP TRIGGER IF EXISTS trigger_enqueue_pomodoro_finished_webhook ON public.pomodoros;
DROP FUNCTION IF EXISTS public.handle_enqueue_pomodoro_finished_webhook();

DROP TRIGGER IF EXISTS trigger_task_done_webhook ON public.tasks;
DROP FUNCTION IF EXISTS public.handle_task_done_webhook();

DROP TRIGGER IF EXISTS trigger_enqueue_task_done_webhook ON public.tasks;
DROP FUNCTION IF EXISTS public.handle_enqueue_task_done_webhook();

-- 5. Producer Function: Enqueue Event
-- SECURITY DEFINER: Allows "authenticated" users to insert into PGMQ without direct permissions on pgmq schema
-- 5. Helper Function: Enqueue generic webhook event
-- Centralizes logic for fetching URL and sending to PGMQ
CREATE OR REPLACE FUNCTION public.enqueue_webhook(
  p_user_id uuid,
  p_event_type text,
  p_payload jsonb
) RETURNS void AS $$
DECLARE
    v_webhook_url text;
BEGIN
    -- Get user webhook URL
    SELECT settings->>'webhook_url' INTO v_webhook_url
    FROM public.profiles
    WHERE id = p_user_id;

    -- If valid URL, enqueue message
    IF v_webhook_url IS NOT NULL AND v_webhook_url <> '' THEN
        PERFORM pgmq.send(
            'pomodoro_webhooks',
            jsonb_build_object(
                'url', v_webhook_url,
                'event', p_event_type,
                'payload', p_payload,
                'timestamp', now()
            )
        );
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pgmq, extensions;


-- 6. Trigger Function: Pomodoro Finished
CREATE OR REPLACE FUNCTION public.handle_enqueue_pomodoro_finished_webhook()
RETURNS trigger AS $$
DECLARE
  v_tags jsonb;
BEGIN
    -- Check for state change to 'finished'
    IF (OLD.state IS DISTINCT FROM 'finished' AND NEW.state = 'finished') THEN
        
        -- Fetch tags associated with the pomodoro
        SELECT jsonb_agg(jsonb_build_object('id', t.id, 'label', t.label, 'type', t.type))
        INTO v_tags
        FROM public.pomodoros_tags pt
        JOIN public.tags t ON pt.tag = t.id
        WHERE pt.pomodoro = NEW.id;

        PERFORM public.enqueue_webhook(
            NEW.user_id,
            'pomodoro.finished',
            jsonb_build_object(
                'id', NEW.id,
                'type', NEW.type,
                'duration', NEW.expected_duration,
                'started_at', NEW.started_at,
                'finished_at', NEW.finished_at,
                'user_id', NEW.user_id,
                'tags', COALESCE(v_tags, '[]'::jsonb)
            )
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pgmq, extensions;

-- Explicitly set search_path for SECURITY DEFINER safety
-- 6. Trigger Definition
CREATE TRIGGER trigger_enqueue_pomodoro_finished_webhook
AFTER UPDATE ON public.pomodoros
FOR EACH ROW
EXECUTE FUNCTION public.handle_enqueue_pomodoro_finished_webhook();

-- 7. Trigger Function: Task Done
CREATE OR REPLACE FUNCTION public.handle_enqueue_task_done_webhook()
RETURNS trigger AS $$
DECLARE
  v_tag jsonb;
BEGIN
    -- Only trigger when done status changes from false (or null) to true
    IF (OLD.done IS DISTINCT FROM true AND NEW.done = true) THEN
        
        -- Fetch tag if exists
        IF NEW.tag_id IS NOT NULL THEN
            SELECT jsonb_build_object('id', t.id, 'label', t.label, 'type', t.type)
            INTO v_tag
            FROM public.tags t
            WHERE t.id = NEW.tag_id;
        END IF;

        PERFORM public.enqueue_webhook(
            NEW.user_id,
            'task.done',
            jsonb_build_object(
                'id', NEW.id,
                'title', NEW.title,
                'description', NEW.description,
                'user_id', NEW.user_id,
                'done_at', NEW.done_at,
                'created_at', NEW.created_at,
                'tag', v_tag
            )
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pgmq, extensions;

DROP TRIGGER IF EXISTS trigger_enqueue_task_done_webhook ON public.tasks;

CREATE TRIGGER trigger_enqueue_task_done_webhook
AFTER UPDATE ON public.tasks
FOR EACH ROW
EXECUTE FUNCTION public.handle_enqueue_task_done_webhook();

-- 7. Consumer Function: Process Queue
-- Also SECURITY DEFINER to ensure cron running this has full access
CREATE OR REPLACE FUNCTION public.process_webhooks()
RETURNS void AS $$
DECLARE
  msg RECORD;
  new_request_id bigint;
  v_user_id uuid;
BEGIN
  -- Read batch of 500 messages (High throughput)
  -- Visibility Timeout 60s
  FOR msg IN 
    SELECT * FROM pgmq.read('pomodoro_webhooks', 60, 500)
  LOOP
    
    -- Extract User ID from payload for tracing
    -- Payload structure: { "payload": { "user_id": "..." } }
    v_user_id := (msg.message->'payload'->>'user_id')::uuid;

    -- Send POST request
    SELECT net.http_post(
        url := msg.message->>'url',
        body := jsonb_build_object(
            'event', msg.message->>'event',
            'payload', msg.message->'payload'
        ),
        headers := '{"Content-Type": "application/json"}'::jsonb
    ) INTO new_request_id;

    -- Log trace
    INSERT INTO public.webhook_trace (pgmq_msg_id, net_request_id, user_id)
    VALUES (msg.msg_id, new_request_id, v_user_id);

    -- Archive message (Move to _archive table)
    PERFORM pgmq.archive('pomodoro_webhooks', msg.msg_id);
    
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pgmq, net, extensions;

-- 8. Status View (Observability)
-- Note: This view accesses protected tables (pgmq, net). 
-- Regular users might get 403 unless they have permissions on schemas.
-- RLS on 'webhook_trace' allows querying that table directly.


drop view if exists "public"."v_webhook_status";
CREATE OR REPLACE VIEW public.v_webhook_status with (security_invoker=on) AS
SELECT 
    A.msg_id,
    A.enqueued_at,
    A.message->>'event' as event_type,
    A.message->>'url' as target_url,
    A.message as full_payload,
    T.processed_at,
    T.user_id,
    R.status_code,
    R.error_msg,
    R.content as response_body
FROM pgmq.a_pomodoro_webhooks A
JOIN public.webhook_trace T ON A.msg_id = T.pgmq_msg_id
LEFT JOIN net._http_response R ON T.net_request_id = R.id
ORDER BY A.enqueued_at DESC;

-- 9. Schedule Cron Jobs (Parallel Workers)

-- Worker 1: Minute 00
SELECT cron.schedule(
  'auto-finish-pomodoros',
  '* * * * *',
  $$ SELECT public.auto_finish_expired_pomodoros() $$
);

-- Worker 1: Minute 00
SELECT cron.schedule(
  'process-webhooks-1',
  '* * * * *',
  $$ SELECT public.process_webhooks() $$
);

-- Worker 2: Minute 00 + 30s offset
SELECT cron.schedule(
  'process-webhooks-2',
  '* * * * *',
  $$ SELECT pg_sleep(30); SELECT public.process_webhooks() $$
);

-- 10. Auto-Cleanup (Daily)
SELECT cron.schedule(
    'clean-old-webhooks', 
    '0 3 * * *',
    $$ 
    DELETE FROM pgmq.a_pomodoro_webhooks WHERE enqueued_at < now() - interval '7 days';
    DELETE FROM public.webhook_trace WHERE processed_at < now() - interval '7 days';
    $$
);




grant delete on table "public"."webhook_trace" to "anon";

grant insert on table "public"."webhook_trace" to "anon";

grant references on table "public"."webhook_trace" to "anon";

grant select on table "public"."webhook_trace" to "anon";

grant trigger on table "public"."webhook_trace" to "anon";

grant truncate on table "public"."webhook_trace" to "anon";

grant update on table "public"."webhook_trace" to "anon";

grant delete on table "public"."webhook_trace" to "authenticated";

grant insert on table "public"."webhook_trace" to "authenticated";

grant references on table "public"."webhook_trace" to "authenticated";

grant select on table "public"."webhook_trace" to "authenticated";

grant trigger on table "public"."webhook_trace" to "authenticated";

grant truncate on table "public"."webhook_trace" to "authenticated";

grant update on table "public"."webhook_trace" to "authenticated";

grant delete on table "public"."webhook_trace" to "service_role";

grant insert on table "public"."webhook_trace" to "service_role";

grant references on table "public"."webhook_trace" to "service_role";

grant select on table "public"."webhook_trace" to "service_role";

grant trigger on table "public"."webhook_trace" to "service_role";

grant truncate on table "public"."webhook_trace" to "service_role";

grant update on table "public"."webhook_trace" to "service_role";

