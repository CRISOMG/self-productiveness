-- Webhooks System Configuration using PGMQ + PG_NET + PG_CRON

-- 1. Ensure Extensions are enabled
CREATE EXTENSION IF NOT EXISTS pgmq;
CREATE EXTENSION IF NOT EXISTS pg_net;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. Create the Queue 'pomodoro_webhooks'
-- Idempotent creation (PGMQ creates tables if they don't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pgmq.list_queues() WHERE queue_name = 'pomodoro_webhooks') THEN
        PERFORM pgmq.create('pomodoro_webhooks');
    END IF;
END $$;

-- 3. Trace Table (Audit Log)
-- Links PGMQ message with PG_NET request
drop table if exists public.webhook_trace;
CREATE TABLE public.webhook_trace (
    id bigint generated by default as identity primary key,
    pgmq_msg_id bigint,          -- Message ID (in queue or archive)
    net_request_id bigint,       -- Request ID from pg_net
    processed_at timestamp with time zone default now(),
    user_id uuid REFERENCES auth.users(id) -- Track user for RLS
);

CREATE INDEX IF NOT EXISTS idx_webhook_trace_msg_id ON public.webhook_trace(pgmq_msg_id);

-- Enable RLS for traceability
ALTER TABLE public.webhook_trace ENABLE ROW LEVEL SECURITY;

-- Allow users to view only their own logs
DROP POLICY IF EXISTS "Users can view their own webhook traces" ON public.webhook_trace;
CREATE POLICY "Users can view their own webhook traces" 
ON public.webhook_trace 
FOR SELECT 
TO authenticated 
USING (user_id = auth.uid());


-- 4. CLEANUP OLD LOGIC (Important to avoid double sending)
DROP TRIGGER IF EXISTS trigger_pomodoro_finished_webhook ON public.pomodoros;
DROP FUNCTION IF EXISTS public.handle_pomodoro_finished_webhook();

-- 5. Producer Function: Enqueue Event
-- SECURITY DEFINER: Allows "authenticated" users to insert into PGMQ without direct permissions on pgmq schema
CREATE OR REPLACE FUNCTION public.encolar_pomodoro_finished()
RETURNS trigger AS $$
DECLARE
    v_webhook_url text;
BEGIN
    -- Check for state change to 'finished'
    IF (OLD.state IS DISTINCT FROM 'finished' AND NEW.state = 'finished') THEN
        
        -- Get user webhook URL
        SELECT settings->>'webhook_url' INTO v_webhook_url
        FROM public.profiles
        WHERE id = NEW.user_id;

        -- If valid URL, enqueue message
        IF v_webhook_url IS NOT NULL AND v_webhook_url <> '' THEN
            PERFORM pgmq.send(
                'pomodoro_webhooks',
                jsonb_build_object(
                    'url', v_webhook_url,
                    'event', 'pomodoro.finished',
                    'payload', jsonb_build_object(
                        'id', NEW.id,
                        'type', NEW.type,
                        'duration', NEW.expected_duration,
                        'started_at', NEW.started_at,
                        'finished_at', NEW.finished_at,
                        'user_id', NEW.user_id
                    ),
                    'timestamp', now()
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Explicitly set search_path for SECURITY DEFINER safety
ALTER FUNCTION public.encolar_pomodoro_finished() SET search_path = public, pgmq, extensions;

-- 6. Trigger Definition
CREATE TRIGGER trigger_encolar_pomodoro_finished
AFTER UPDATE ON public.pomodoros
FOR EACH ROW
EXECUTE FUNCTION public.encolar_pomodoro_finished();

-- 7. Consumer Function: Process Queue
-- Also SECURITY DEFINER to ensure cron running this has full access
CREATE OR REPLACE FUNCTION public.procesar_webhooks_pomodoro()
RETURNS void AS $$
DECLARE
  msg RECORD;
  new_request_id bigint;
  v_user_id uuid;
BEGIN
  -- Read batch of 500 messages (High throughput)
  -- Visibility Timeout 60s
  FOR msg IN 
    SELECT * FROM pgmq.read('pomodoro_webhooks', 60, 500)
  LOOP
    
    -- Extract User ID from payload for tracing
    -- Payload structure: { "payload": { "user_id": "..." } }
    v_user_id := (msg.message->'payload'->>'user_id')::uuid;

    -- Send POST request
    SELECT net.http_post(
        url := msg.message->>'url',
        body := jsonb_build_object(
            'event', msg.message->>'event',
            'payload', msg.message->'payload'
        ),
        headers := '{"Content-Type": "application/json"}'::jsonb
    ) INTO new_request_id;

    -- Log trace
    INSERT INTO public.webhook_trace (pgmq_msg_id, net_request_id, user_id)
    VALUES (msg.msg_id, new_request_id, v_user_id);

    -- Archive message (Move to _archive table)
    PERFORM pgmq.archive('pomodoro_webhooks', msg.msg_id);
    
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8. Status View (Observability)
-- Note: This view accesses protected tables (pgmq, net). 
-- Regular users might get 403 unless they have permissions on schemas.
-- RLS on 'webhook_trace' allows querying that table directly.


drop view if exists "public"."v_webhook_status";
CREATE OR REPLACE VIEW public.v_webhook_status with (security_invoker=on) AS
SELECT 
    A.msg_id,
    A.enqueued_at,
    A.message->>'event' as event_type,
    A.message->>'url' as target_url,
    A.message as full_payload,
    T.processed_at,
    T.user_id,
    R.status_code,
    R.error_msg,
    R.content as response_body
FROM pgmq.a_pomodoro_webhooks A
JOIN public.webhook_trace T ON A.msg_id = T.pgmq_msg_id
LEFT JOIN net._http_response R ON T.net_request_id = R.id
ORDER BY A.enqueued_at DESC;

-- 9. Schedule Cron Jobs (Parallel Workers)

-- Worker 1: Minute 00
SELECT cron.schedule(
  'process-webhooks-1',
  '* * * * *',
  $$ SELECT public.procesar_webhooks_pomodoro() $$
);

-- Worker 2: Minute 00 + 30s offset
SELECT cron.schedule(
  'process-webhooks-2',
  '* * * * *',
  $$ SELECT pg_sleep(30); SELECT public.procesar_webhooks_pomodoro() $$
);

-- 10. Auto-Cleanup (Daily)
SELECT cron.schedule(
    'clean-old-webhooks', 
    '0 3 * * *',
    $$ 
    DELETE FROM pgmq.a_pomodoro_webhooks WHERE enqueued_at < now() - interval '7 days';
    DELETE FROM public.webhook_trace WHERE processed_at < now() - interval '7 days';
    $$
);




grant delete on table "public"."webhook_trace" to "anon";

grant insert on table "public"."webhook_trace" to "anon";

grant references on table "public"."webhook_trace" to "anon";

grant select on table "public"."webhook_trace" to "anon";

grant trigger on table "public"."webhook_trace" to "anon";

grant truncate on table "public"."webhook_trace" to "anon";

grant update on table "public"."webhook_trace" to "anon";

grant delete on table "public"."webhook_trace" to "authenticated";

grant insert on table "public"."webhook_trace" to "authenticated";

grant references on table "public"."webhook_trace" to "authenticated";

grant select on table "public"."webhook_trace" to "authenticated";

grant trigger on table "public"."webhook_trace" to "authenticated";

grant truncate on table "public"."webhook_trace" to "authenticated";

grant update on table "public"."webhook_trace" to "authenticated";

grant delete on table "public"."webhook_trace" to "service_role";

grant insert on table "public"."webhook_trace" to "service_role";

grant references on table "public"."webhook_trace" to "service_role";

grant select on table "public"."webhook_trace" to "service_role";

grant trigger on table "public"."webhook_trace" to "service_role";

grant truncate on table "public"."webhook_trace" to "service_role";

grant update on table "public"."webhook_trace" to "service_role";

