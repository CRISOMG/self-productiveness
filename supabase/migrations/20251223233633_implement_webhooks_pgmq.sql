-- Webhooks System Configuration using PGMQ + PG_NET + PG_CRON

-- 1. Ensure Extensions are enabled
CREATE EXTENSION IF NOT EXISTS pgmq;
CREATE EXTENSION IF NOT EXISTS pg_net;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. Create the Queue 'pomodoro_webhooks'
-- Idempotent creation (PGMQ creates tables if they don't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pgmq.list_queues() WHERE queue_name = 'pomodoro_webhooks') THEN
        PERFORM pgmq.create('pomodoro_webhooks');
    END IF;
END $$;

-- 3. Trace Table (Audit Log)
-- Links PGMQ message with PG_NET request
CREATE TABLE IF NOT EXISTS public.webhook_trace (
    id bigint generated by default as identity primary key,
    pgmq_msg_id bigint,          -- Message ID (in queue or archive)
    net_request_id bigint,       -- Request ID from pg_net
    processed_at timestamp with time zone default now()
);

CREATE INDEX IF NOT EXISTS idx_webhook_trace_msg_id ON public.webhook_trace(pgmq_msg_id);

-- 4. CLEANUP OLD LOGIC (Important to avoid double sending)
DROP TRIGGER IF EXISTS trigger_pomodoro_finished_webhook ON public.pomodoros;
DROP FUNCTION IF EXISTS public.handle_pomodoro_finished_webhook();

-- 5. Producer Function: Enqueue Event
CREATE OR REPLACE FUNCTION public.encolar_pomodoro_finished()
RETURNS trigger AS $$
DECLARE
    v_webhook_url text;
BEGIN
    -- Check for state change to 'finished'
    IF (OLD.state IS DISTINCT FROM 'finished' AND NEW.state = 'finished') THEN
        
        -- Get user webhook URL
        SELECT settings->>'webhook_url' INTO v_webhook_url
        FROM public.profiles
        WHERE id = NEW.user_id;

        -- If valid URL, enqueue message
        IF v_webhook_url IS NOT NULL AND v_webhook_url <> '' THEN
            PERFORM pgmq.send(
                'pomodoro_webhooks',
                jsonb_build_object(
                    'url', v_webhook_url,
                    'event', 'pomodoro.finished',
                    'payload', jsonb_build_object(
                        'id', NEW.id,
                        'type', NEW.type,
                        'duration', NEW.expected_duration,
                        'started_at', NEW.started_at,
                        'finished_at', NEW.finished_at,
                        'user_id', NEW.user_id
                    ),
                    'timestamp', now()
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 6. Trigger Definition
CREATE OR REPLACE TRIGGER trigger_encolar_pomodoro_finished
AFTER UPDATE ON public.pomodoros
FOR EACH ROW
EXECUTE FUNCTION public.encolar_pomodoro_finished();

-- 7. Consumer Function: Process Queue
CREATE OR REPLACE FUNCTION public.procesar_webhooks_pomodoro()
RETURNS void AS $$
DECLARE
  msg RECORD;
  new_request_id bigint;
BEGIN
  -- Read batch of 500 messages (High throughput)
  -- Visibility Timeout 60s
  FOR msg IN 
    SELECT * FROM pgmq.read('pomodoro_webhooks', 60, 500)
  LOOP
    
    -- Send POST request
    SELECT net.http_post(
        url := msg.message->>'url',
        body := msg.message->'payload',
        headers := '{"Content-Type": "application/json"}'::jsonb
    ) INTO new_request_id;

    -- Log trace
    INSERT INTO public.webhook_trace (pgmq_msg_id, net_request_id)
    VALUES (msg.msg_id, new_request_id);

    -- Archive message (Move to _archive table)
    PERFORM pgmq.archive('pomodoro_webhooks', msg.msg_id);
    
  END LOOP;
END;
$$ LANGUAGE plpgsql;


-- 9. Schedule Cron Jobs (Parallel Workers)

-- Worker 1: Minute 00
SELECT cron.schedule(
  'process-webhooks-1',
  '* * * * *',
  $$ SELECT public.procesar_webhooks_pomodoro() $$
);

-- Worker 2: Minute 00 + 30s offset
SELECT cron.schedule(
  'process-webhooks-2',
  '* * * * *',
  $$ SELECT pg_sleep(30); SELECT public.procesar_webhooks_pomodoro() $$
);

-- 10. Auto-Cleanup (Daily)
SELECT cron.schedule(
    'clean-old-webhooks', 
    '0 3 * * *',
    $$ 
    DELETE FROM pgmq.a_pomodoro_webhooks WHERE enqueued_at < now() - interval '7 days';
    DELETE FROM public.webhook_trace WHERE processed_at < now() - interval '7 days';
    $$
);
