drop trigger if exists "trigger_pomodoro_finished_webhook" on "public"."pomodoros";

drop function if exists "public"."handle_pomodoro_finished_webhook"();


drop view if exists "public"."v_webhook_status";
drop table if exists "public"."webhook_trace";


  create table "public"."webhook_trace" (
    "id" bigint generated by default as identity not null,
    "pgmq_msg_id" bigint,
    "net_request_id" bigint,
    "processed_at" timestamp with time zone default now(),
    "user_id" uuid
      );


alter table "public"."webhook_trace" enable row level security;

CREATE INDEX idx_webhook_trace_msg_id ON public.webhook_trace USING btree (pgmq_msg_id);

CREATE UNIQUE INDEX webhook_trace_pkey ON public.webhook_trace USING btree (id);

alter table "public"."webhook_trace" add constraint "webhook_trace_pkey" PRIMARY KEY using index "webhook_trace_pkey";

alter table "public"."webhook_trace" add constraint "webhook_trace_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."webhook_trace" validate constraint "webhook_trace_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.encolar_pomodoro_finished()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pgmq', 'extensions'
AS $function$
DECLARE
    v_webhook_url text;
BEGIN
    -- Check for state change to 'finished'
    IF (OLD.state IS DISTINCT FROM 'finished' AND NEW.state = 'finished') THEN
        
        -- Get user webhook URL
        SELECT settings->>'webhook_url' INTO v_webhook_url
        FROM public.profiles
        WHERE id = NEW.user_id;

        -- If valid URL, enqueue message
        IF v_webhook_url IS NOT NULL AND v_webhook_url <> '' THEN
            PERFORM pgmq.send(
                'pomodoro_webhooks',
                jsonb_build_object(
                    'url', v_webhook_url,
                    'event', 'pomodoro.finished',
                    'payload', jsonb_build_object(
                        'id', NEW.id,
                        'type', NEW.type,
                        'duration', NEW.expected_duration,
                        'started_at', NEW.started_at,
                        'finished_at', NEW.finished_at,
                        'user_id', NEW.user_id
                    ),
                    'timestamp', now()
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.procesar_webhooks_pomodoro()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  msg RECORD;
  new_request_id bigint;
  v_user_id uuid;
BEGIN
  -- Read batch of 500 messages (High throughput)
  -- Visibility Timeout 60s
  FOR msg IN 
    SELECT * FROM pgmq.read('pomodoro_webhooks', 60, 500)
  LOOP
    
    -- Extract User ID from payload for tracing
    -- Payload structure: { "payload": { "user_id": "..." } }
    v_user_id := (msg.message->'payload'->>'user_id')::uuid;

    -- Send POST request
    SELECT net.http_post(
        url := msg.message->>'url',
        body := msg.message->'payload',
        headers := '{"Content-Type": "application/json"}'::jsonb
    ) INTO new_request_id;

    -- Log trace
    INSERT INTO public.webhook_trace (pgmq_msg_id, net_request_id, user_id)
    VALUES (msg.msg_id, new_request_id, v_user_id);

    -- Archive message (Move to _archive table)
    PERFORM pgmq.archive('pomodoro_webhooks', msg.msg_id);
    
  END LOOP;
END;
$function$
;

create or replace view "public"."v_webhook_status" with (security_invoker=on) 
as SELECT a.msg_id,
    a.enqueued_at,
    (a.message ->> 'event'::text) AS event_type,
    (a.message ->> 'url'::text) AS target_url,
    a.message AS full_payload,
    t.processed_at,
    t.user_id,
    r.status_code,
    r.error_msg,
    r.content AS response_body
   FROM ((pgmq.a_pomodoro_webhooks a
     JOIN public.webhook_trace t ON ((a.msg_id = t.pgmq_msg_id)))
     LEFT JOIN net._http_response r ON ((t.net_request_id = r.id)))
  ORDER BY a.enqueued_at DESC;


grant delete on table "public"."webhook_trace" to "anon";

grant insert on table "public"."webhook_trace" to "anon";

grant references on table "public"."webhook_trace" to "anon";

grant select on table "public"."webhook_trace" to "anon";

grant trigger on table "public"."webhook_trace" to "anon";

grant truncate on table "public"."webhook_trace" to "anon";

grant update on table "public"."webhook_trace" to "anon";

grant delete on table "public"."webhook_trace" to "authenticated";

grant insert on table "public"."webhook_trace" to "authenticated";

grant references on table "public"."webhook_trace" to "authenticated";

grant select on table "public"."webhook_trace" to "authenticated";

grant trigger on table "public"."webhook_trace" to "authenticated";

grant truncate on table "public"."webhook_trace" to "authenticated";

grant update on table "public"."webhook_trace" to "authenticated";

grant delete on table "public"."webhook_trace" to "service_role";

grant insert on table "public"."webhook_trace" to "service_role";

grant references on table "public"."webhook_trace" to "service_role";

grant select on table "public"."webhook_trace" to "service_role";

grant trigger on table "public"."webhook_trace" to "service_role";

grant truncate on table "public"."webhook_trace" to "service_role";

grant update on table "public"."webhook_trace" to "service_role";


  create policy "Users can view their own webhook traces"
  on "public"."webhook_trace"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));


CREATE OR REPLACE TRIGGER trigger_encolar_pomodoro_finished AFTER UPDATE ON public.pomodoros FOR EACH ROW EXECUTE FUNCTION public.encolar_pomodoro_finished();


